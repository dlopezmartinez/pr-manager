name: "Bump Version"
description: "Bump semantic version in all package.json files"

inputs:
  type:
    description: "Version bump type (beta, patch, minor, major)"
    required: true
  current-version:
    description: "Current version (if not provided, reads from package.json)"
    required: false

outputs:
  new-version:
    description: "The new version after bump"
    value: ${{ steps.bump.outputs.new_version }}
  previous-version:
    description: "The version before bump"
    value: ${{ steps.bump.outputs.previous_version }}
  is-prerelease:
    description: "Whether the new version is a prerelease"
    value: ${{ steps.bump.outputs.is_prerelease }}

runs:
  using: "composite"
  steps:
    - name: "Calculate new version"
      id: bump
      shell: bash
      run: |
        # Get current version
        if [ -n "${{ inputs.current-version }}" ]; then
          CURRENT="${{ inputs.current-version }}"
        else
          CURRENT=$(node -p "require('./package.json').version")
        fi
        echo "previous_version=$CURRENT" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT"

        # Parse version components
        # Handle both X.Y.Z and X.Y.Z-beta.N formats
        if [[ "$CURRENT" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)(-([a-z]+)\.([0-9]+))?$ ]]; then
          MAJOR="${BASH_REMATCH[1]}"
          MINOR="${BASH_REMATCH[2]}"
          PATCH="${BASH_REMATCH[3]}"
          PRERELEASE_TYPE="${BASH_REMATCH[5]}"
          PRERELEASE_NUM="${BASH_REMATCH[6]}"
        else
          echo "::error::Invalid version format: $CURRENT"
          exit 1
        fi

        case "${{ inputs.type }}" in
          beta)
            if [ -n "$PRERELEASE_TYPE" ] && [ "$PRERELEASE_TYPE" == "beta" ]; then
              # Already a beta, increment beta number
              NEW_PRERELEASE_NUM=$((PRERELEASE_NUM + 1))
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-beta.${NEW_PRERELEASE_NUM}"
            else
              # Not a beta, create new beta for next patch
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}-beta.1"
            fi
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            ;;
          patch)
            if [ -n "$PRERELEASE_TYPE" ]; then
              # Remove prerelease suffix for stable release
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            else
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            fi
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            ;;
          minor)
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            ;;
          major)
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="${NEW_MAJOR}.0.0"
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "::error::Invalid bump type: ${{ inputs.type }}"
            exit 1
            ;;
        esac

        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "Version bump: $CURRENT -> $NEW_VERSION"

    - name: "Update package.json files"
      shell: bash
      env:
        NEW_VERSION: ${{ steps.bump.outputs.new_version }}
      run: |
        echo "Updating all package.json files to v$NEW_VERSION"

        # Update root package.json
        npm version $NEW_VERSION --no-git-tag-version

        # Update workspace packages
        for pkg in packages/app packages/backend packages/landing; do
          if [ -f "$pkg/package.json" ]; then
            cd "$pkg"
            npm version $NEW_VERSION --no-git-tag-version
            cd - > /dev/null
          fi
        done

        echo "All package versions synchronized to v$NEW_VERSION"
